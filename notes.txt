pointers point to an address
&name gives the address of a variable
*name declares a pointers
*name also gets the value
int number[5] = {1,2,3,4,5}; // common array
cout << number << endl; // gives address
cout << *number << endl; gives // first number
cout << *(++number) << endl; // gives second number
if pointer is increased by one it points to the next element
if decreased, it points to the previous

ex:
int num[5] = {1,2,3,4,5};
int *p = num;
cout << *(p++) << endl; // prints 1
cout << *(++p) << endl; // prints 3
cout << ++*p << endl; // prints 4
cout << (*p)++ << endl; // prints 3

void == no return type
void pointers usually applies to function return type

null pointer is value that points to "nowhere"
int *p = NULL;

pass by reference is preferred

"free store" / "the heap"
double *j = new double(1.2); // value initialized
delete j;
int *v = new int[n];
delete []v;

VECTOR
vectors are placed in contiguous memory
vectors are arrays that can change size // think of a list
insert/delete is at the end of a vector
you can use iterators
vector<int> v1 = {1,2,3,4,5}; // initialize vector
vector<int> v2(5,12); // {12,12,12,12,12}
v1.push_back(6); //  adds integer 6 to end of vector
v1.pop_back(); // deletes last element
v1.at(4) = 9; // change the element at index 4 to 9
v1.front; // returns first element
v1.back; // returns last element

STACK
An ordered list of similar data types
Last one in, first one out (LIFO/FILO)
Push adds element to stack
Pop removes element from stack
cannot change the internal elements
peek looks at the top elemet without removing it
isFull/isEmpty check exactly that
Overflow: pushing a new element to a full stack
Underflow: Popping from an empty stack

QUEUE
linear and ordered list of similar items
first on in, first one out (FIFO)
engueue adds element to front
dequeue removes element from rear
cannot change the internal elements
front/back can peek the front and back respectively
isFull/isEmpty check exactly that

TEMPLATE
Is a blueprint for creating a generic class or function
Passes in data types as a parameter into a function so there is no need to write the same for differenet data types
It enables the compiler to write the specific code to execute during run time based on the rules
Templates are only expended at compiling time
Examples: max(), min(), print(), etc.
Basic syntax for function template:
    template<typename T>
    Function_type Function_name(T parameter_name){...}
Example:
    template<typename T>
    void Print(T value){
        cout << value << endl;
    }
This Print function can take in any data type
Class template is a class type that is independent of the data type
Can be used to achieve polymorphism
Examples: array, linked list, vector, stack, queue, etc.
Basic syntax for class template:
    template<typename T, Parameter_Type Parameter_Name> class 
    Class_Name{...}
Templates is best used with the combination of inheritance
There is no definitive answer to when to use a template